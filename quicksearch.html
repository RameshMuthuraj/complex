<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_client.js.html":{"id":"lib_client.js.html","title":"Source: lib/client.js","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Source: lib/client.js 'use strict'; var request = require('request'); var assert = require('assert'); var storj = require('storj-lib'); var uuid = require('node-uuid'); var merge = require('merge'); /** * Creates a RPC client for communicating with a {@link Landlord} * @constructor * @param {Object} options * @param {String} options.rpcUrl - The URL of the Landlord RPC server * @param {String} options.rpcUser - Authorization username * @param {String} options.rpcPassword - Authorization password */ function Client(options) { if (!(this instanceof Client)) { return new Client(options); } this._opts = merge(Object.create(Client.DEFAULTS), options); } Client.DEFAULTS = { rpcUrl: 'http://localhost:8080', rpcUser: 'user', rpcPassword: 'pass' }; /** * Sends the JSON-RPC message and handles the response * @param {String} method * @param {Array} args * @param {Function} callback * @private */ Client.prototype._send = function(method, args, callback) { var self = this; request.post(this._opts.rpcUrl, { id: uuid.v4(), method: method, params: this._serializeRequestArguments(method, args) }, function(err, body) { if (err) { return callback(err); } if (body.error) { return callback(new Error(body.error.message)); } callback.apply( null, self._deserializeResponseArguments(method, body.result) ); }); }; /** * Converts response params into storj-lib objects * @param {String} method * @param {Array} arguments * @returns {Array} */ Client.prototype._deserializeResponseArguments = function(method, args) { switch (method) { case 'getStorageOffer': args[1] = storj.Contact(args[1]); args[2] = storj.Contract.fromObject(args[2]); break; case 'getStorageProof': break; case 'getConsignmentPointer': args[1] = storj.DataChannelPointer( storj.Contact(args[1].farmer), args[1].hash, args[1].token, args[1].operation ); break; case 'getRetrievalPointer': args[1] = storj.DataChannelPointer( storj.Contact(args[1].farmer), args[1].hash, args[1].token, args[1].operation ); break; case 'getMirrorNodes': args[1] = args[1].map(function(c) { return storj.Contact(c); }); break; default: // noop } return args; }; /** * Converts storj-lib objects into request params * @param {String} method * @param {Array} arguments * @returns {Array} */ Client.prototype._serializeRequestArguments = function(method, args) { switch (method) { case 'getStorageOffer': args[0] = args[0].toObject(); break; case 'getStorageProof': break; case 'getConsignmentPointer': args[1] = args[1].toObject(); args[2] = { challenges: args[2].getPrivateRecord().challenges, tree: args[2].getPublicRecord() }; break; case 'getRetrievalPointer': args[1] = args[1].toObject(); break; case 'getMirrorNodes': break; default: // noop } return args; }; /** * @see http://storj.github.io/core/RenterInterface.html */ Client.prototype.getConsignmentPointer = function(f, c, a, callback) { assert(f instanceof storj.Contact, 'Invalid contact supplied'); assert(c instanceof storj.Contract, 'Invalid contract supplied'); assert(a instanceof storj.AuditStream, 'Invalid audit object supplied'); this._send('getConsignmentPointer', [f, c, a], callback); }; /** * @see http://storj.github.io/core/RenterInterface.html */ Client.prototype.getRetrievalPointer = function(farmer, contract, callback) { assert(farmer instanceof storj.Contact, 'Invalid contact supplied'); assert(contract instanceof storj.Contract, 'Invalid contract supplied'); this._send('getRetrievalPointer', [farmer, contract], callback); }; /** * @see http://storj.github.io/core/RenterInterface.html */ Client.prototype.getMirrorNodes = function(sources, destinations, callback) { assert(Array.isArray(sources), 'Invalid sources supplied'); assert(Array.isArray(destinations), 'Invalid destinations supplied'); sources.forEach(function(source) { assert(source instanceof storj.DataChannelPointer, 'Invalid pointer'); }); destinations.forEach(function(dest) { assert(dest instanceof storj.Contact, 'Invalid contact'); }); this._send('getMirrorNodes', [sources, destinations], callback); }; /** * @see http://storj.github.io/core/RenterInterface.html */ Client.prototype.getStorageOffer = function(contract, blacklist, callback) { if (typeof blacklist === 'function') { callback = blacklist; blacklist = []; } assert(contract instanceof storj.Contract, 'Invalid contract supplied'); assert(Array.isArray(blacklist), 'Invalid blacklist supplied'); this._send('getStorageOffer', [contract, blacklist], callback); }; /** * @see http://storj.github.io/core/RenterInterface.html */ Client.prototype.getStorageProof = function(farmer, item, callback) { assert(farmer instanceof storj.Contact, 'Invalid contact supplied'); assert(item instanceof storj.StorageItem, 'Invalid storage item supplied'); this._send('getStorageProof', [farmer, item], callback); }; module.exports = Client; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Source: index.js 'use strict'; /** {@link module:complex/config} */ module.exports.createConfig = require('./lib/config'); /** {@link Landlord} */ module.exports.createLandlord = require('./lib/landlord'); /** {@link Renter} */ module.exports.createRenter = require('./lib/renter'); /** {@link Client} */ module.exports.createClient = require('./lib/client'); × Search results Close "},"lib_landlord.js.html":{"id":"lib_landlord.js.html","title":"Source: lib/landlord.js","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Source: lib/landlord.js 'use strict'; var restify = require('restify'); var storj = require('storj-lib'); var ReadableStream = require('readable-stream'); var inherits = require('util').inherits; var rabbitmq = require('rabbit.js'); var Logger = require('kad-logger-json'); var merge = require('merge'); var assert = require('assert'); var LandlordConfig = require('./config').LandlordConfig; /** * Creates an RPC server for issuing work to a renter pool * @constructor * @param {Object} options * @param {Number} options.serverPort - The port to listen on * @param {Object} options.serverOpts - Options to pass wot Restify server * @param {String} options.amqpUrl - The RabbitMQ server URL * @param {Object} options.amqpOpts - Option to pass to RabbitMQ context * @param {Number} options.logLevel - The verbosity level for logging */ function Landlord(options) { if (!(this instanceof Landlord)) { return new Landlord(options); } this._opts = options instanceof LandlordConfig ? options.toObject() : options; this._logger = new Logger(this._opts.logLevel); this._pendingResponses = {}; this.server = restify.createServer(merge({ name: 'Storj Complex', version: require('../package.json').version }, this._opts.serverOpts)); this._bindServerRoutes(); ReadableStream.call(this); this._logger.on('data', this.push.bind(this)); } inherits(Landlord, ReadableStream); Landlord.REQUEST_TIMEOUT = 30000; /** * @private */ Landlord.prototype._read = storj.utils.noop; /** * Binds the server routes * @private */ Landlord.prototype._bindServerRoutes = function() { this._logger.info('binding rpc server routes'); this.server.use(restify.authorizationParser()); this.server.use(restify.bodyParser()); this.server.post('/', this._handleJsonRpcRequest.bind(this)); }; /** * Starts the landlord service * @param {Landlord~startCallback} */ Landlord.prototype.start = function(callback) { var self = this; // Start our RPC server this._logger.info('starting rpc server on port %s', this._opts.serverPort); this.server.listen(this._opts.serverPort); // Set up our RabbitMQ context this._amqpContext = rabbitmq.createContext( this._opts.amqpUrl, this._opts.amqpOpts ); // When our context is good, set up our subscriptions this._logger.info('opening connection to rabbitmq'); this._amqpContext.on('ready', this._initMessageBus.bind(this)); // When we are all connected, fire the callback this.once('ready', function() { self._logger.info('landlord is connected and listening'); this.removeAllListeners('error'); callback(); }); // Otherwise bubble any errors this.once('error', function(err) { this.removeAllListeners('ready'); callback(err); }); }; /** * @callback Landlord~startCallback * @param {Error} [error] */ /** * Initialize the rabbitmq message bus * @private */ Landlord.prototype._initMessageBus = function() { this._logger.info('initializing message bus'); // Setup our amqp sockets this.publisher = this._amqpContext.socket('PUBLISH'); this.subscriber = this._amqpContext.socket('SUBSCRIBE'); this.pusher = this._amqpContext.socket('PUSH'); // Connect to our renter minion and listen for finished work this.publisher.connect('pool'); this.subscriber.connect('work.close'); this.pusher.connect('work.open'); // Set up handlers for receiving work // Set up handlers for renter alerts this.subscriber.on('data', this._handleWorkResult.bind(this)); this.emit('ready'); }; /** * Handles an incoming JSON-RPC request * @private */ Landlord.prototype._handleJsonRpcRequest = function(req, res) { var self = this; var authRequest = req.authorization.basic; var authConfig = this._opts.serverOpts.authorization; // Make sure that the auth credentials match what's configured if ( !(authRequest.username === authConfig.user &amp;&amp; authRequest.password === authConfig.pass) ) { this._logger.warn('unauthorized rpc attempt'); return res.send(new restify.errors.UnauthorizedError()); } // Make sure this is a valid JSON RPC request if (!this._isValidJsonRpcRequest(req.body)) { this._logger.warn('invalid rpc message received'); return res.send(new restify.errors.BadRequestError()); } // Keep track of the response object for later this._pendingResponses[req.body.id] = res; // Add work to the renter pool this._logger.info('writing to worker pool'); this._logger.debug('rpc: %j', req.body); this.pusher.write(new Buffer(JSON.stringify(req.body))); // If work isn't completed in time, respond with an error setTimeout(function() { if (!self._pendingResponses[req.body.id]) { return; } self._logger.warn('job %s timed out', req.body.id); self._pendingResponses[req.body.id].send( new restify.errors.RequestTimeoutError() ); delete self._pendingResponses[req.body.id]; }, Landlord.REQUEST_TIMEOUT); }; /** * Validates a JSON-RPC request * @private */ Landlord.prototype._isValidJsonRpcRequest = function(body) { try { assert(typeof body.id === 'string'); assert(Array.isArray(body.params)); assert(typeof body.method === 'string'); } catch (err) { return false; } return true; }; /** * Handle the result of some work completed * @private */ Landlord.prototype._handleWorkResult = function(buffer) { var self = this; var data = JSON.parse(buffer.toString()); // If this response already timed out do nothing if (!self._pendingResponses[data.id]) { return this._logger.warn('job %s completed late', data.id); } // If we got error back, then send a error code if (data.error) { self._logger.warn('error returned from work result on job %s', data.id); self._logger.debug('error result: %j', data); return self._pendingResponses[data.id].send( new restify.errors.InternalServerError(data.error.message) ); } data.result = this._objectToArray(data.result); // Otherwise forward the result and delete the reference self._logger.info('job %s completed successfully', data.id); self._logger.debug('job result: %j', data); self._pendingResponses[data.id].send(data); delete self._pendingResponses[data.id]; }; /** * Convert data.result into a actual array * @private */ Landlord.prototype._objectToArray = function(obj) { var args = []; for (var i = 0; i &lt; Object.keys(obj).length; i++) { args[i] = obj[i]; } return args; }; module.exports = Landlord; × Search results Close "},"lib_config.js.html":{"id":"lib_config.js.html","title":"Source: lib/config.js","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Source: lib/config.js /** * @module complex/config */ 'use strict'; var fs = require('fs'); var assert = require('assert'); var inherits = require('util').inherits; /** * Abstract config for renters and landlords * @constructor * @param {Object} config * @param {String} config.amqpUrl - The URL for RabbitMQ * @param {Object} config.amqpOpts - Options to pass to Rabbit.js * @param {Number} config.logLevel - Verbosity level for logging */ function BaseConfig(config) { if (!(this instanceof BaseConfig)) { return new BaseConfig(config); } this._ = {}; assert.ok(config, 'No config supplied'); assert(typeof config.logLevel === 'number', 'Invalid logLevel'); assert(typeof config.amqpUrl === 'string', 'Invalid amqpUrl'); assert(typeof config.amqpOpts === 'object', 'Invalid amqpOpts'); this._.logLevel = config.logLevel; this._.amqpUrl = config.amqpUrl; this._.amqpOpts = config.amqpOpts; } /** * Returns an plain object */ BaseConfig.prototype.toObject = function() { return Object.create(this._); }; /** * Config for renters * @constructor * @extends {BaseConfig} * @param {Object} options * @param {String} options.mongoUrl - The URL for the MongoDB * @param {Object} options.mongoOpts - Options to pass to Mongoose * @param {String} options.networkPrivateKey - The private key for the renter * @param {Object} options.networkOpts - Options to pass to RenterInterface */ function RenterConfig(options) { if (!(this instanceof RenterConfig)) { return new RenterConfig(options); } BaseConfig.call(this, options); assert(typeof options.mongoUrl === 'string', 'Invalid mongoUrl'); assert(typeof options.mongoOpts === 'object', 'Invalid mongoOpts'); assert( typeof options.networkPrivateKey === 'string', 'Invalid networkPrivateKey' ); assert(typeof options.networkOpts === 'object', 'Invalid networkOpts'); this._.networkPrivateKey = options.networkPrivateKey; this._.networkOpts = options.networkOpts; this._.mongoUrl = options.mongoUrl; this._.mongoOpts = options.mongoOpts; } inherits(RenterConfig, BaseConfig); /** * Config for landlords * @constructor * @extends {BaseConfig} * @param {Object} options * @param {Number} options.serverPort - The port to listen on * @param {Object} options.serverOpts * @param {String} options.serverOpts.certificate - PEM SSL certificate * @param {String} options.serverOpts.key - PEM SSL key */ function LandlordConfig(options) { if (!(this instanceof LandlordConfig)) { return new LandlordConfig(options); } BaseConfig.call(this, options); assert(typeof options.serverPort === 'number', 'Invalid serverPort'); assert(typeof options.serverOpts === 'object', 'Invalid serverOpts'); this._.serverPort = options.serverPort; this._.serverOpts = options.serverOpts; this._.serverOpts.authorization = options.serverOpts.authorization || {}; } inherits(LandlordConfig, BaseConfig); /** * Loads the appropriate config type * @function * @param {String} configFilePath - The path to the config file on disk */ module.exports= function(configFilePath) { var configBuffer = fs.readFileSync(configFilePath); var parsedConfig = JSON.parse(configBuffer.toString()); function _createConfig(config) { assert(typeof config.type === 'string', 'Invalid type supplied'); assert( ['Renter', 'Landlord'].indexOf(config.type) !== -1, 'Invalid type supplied' ); assert(typeof config.opts === 'object', 'Invalid opts supplied'); switch (config.type) { case 'Renter': config = new RenterConfig(config.opts); config._.networkPrivateKey = fs.readFileSync( config._.networkPrivateKey ).toString('utf8').split('\\n').join(''); break; case 'Landlord': config = new LandlordConfig(config.opts); if (config._.serverOpts.certificate) { config._.serverOpts.certificate = fs.readFileSync( config._.serverOpts.certificate ).toString('utf8'); } if (config._.serverOpts.key) { config._.serverOpts.key = fs.readFileSync( config._.serverOpts.key ).toString('utf8'); } break; default: // noop } return config; } if (!Array.isArray(parsedConfig)) { return _createConfig(parsedConfig); } else { return parsedConfig.map(_createConfig); } }; module.exports.RenterConfig = RenterConfig; module.exports.LandlordConfig = LandlordConfig; module.exports.BaseConfig = BaseConfig; × Search results Close "},"lib_renter.js.html":{"id":"lib_renter.js.html","title":"Source: lib/renter.js","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Source: lib/renter.js 'use strict'; var storj = require('storj-lib'); var MongoStorageAdapter = require('storj-mongodb-adapter'); var ReadableStream = require('readable-stream'); var inherits = require('util').inherits; var rabbitmq = require('rabbit.js'); var Logger = require('kad-logger-json'); var uuid = require('node-uuid'); var RenterConfig = require('./config').RenterConfig; var mongoose = require('mongoose'); /** * Create a renter interface capable of coordinating with other renters * @constructor * @param {Object} options * @param {String} options.mongoUrl - The URL for the MongoDB * @param {Object} options.mongoOpts - Options to pass to Mongoose * @param {String} options.networkPrivateKey - The private key for the renter * @param {Object} options.networkOpts - Options to pass to RenterInterface * @param {String} options.amqpUrl - The URL for the RabbitMQ server * @param {Object} options.amqpOpts - Options to pass the RabbitMQ context * @param {Number} options.logLevel - The verbosity level for logging */ function Renter(options) { if (!(this instanceof Renter)) { return new Renter(options); } this._opts = options instanceof RenterConfig ? options.toObject() : options; this._logger = new Logger(this._opts.logLevel); this._pendingCallbacks = {}; ReadableStream.call(this); this._logger.on('data', this.push.bind(this)); } inherits(Renter, ReadableStream); Renter.SAFE_LANDLORD_METHODS = [ 'getConsignmentPointer', 'getRetrievalPointer', 'getMirrorNodes', 'getStorageOffer', 'getStorageProof' ]; Renter.SAFE_POOL_METHODS = [ 'isAwaitingOffer', 'acceptOffer' ]; Renter.POOL_REQUEST_TIMEOUT = 5000; /** * @private */ Renter.prototype._read = storj.utils.noop; /** * Starts the renter service * @param {Renter~startCallback} */ Renter.prototype.start = function(callback) { // Set up our database connection for shared contract storage this.storage = mongoose.createConnection( this._opts.mongoUrl, this._opts.mongoOpts ); // Set up our RabbitMQ context this._amqpContext = rabbitmq.createContext( this._opts.amqpUrl, this._opts.amqpOpts ); // Set up our network interface to Storj this.network = storj.RenterInterface({ storageManager: storj.StorageManager(MongoStorageAdapter(this.storage)), rpcPort: this._opts.networkOpts.rpcPort, rpcAddress: this._opts.networkOpts.rpcAddress, keyPair: storj.KeyPair(this._opts.networkPrivateKey), doNotTraverseNat: this._opts.networkOpts.doNotTraverseNat, maxTunnels: this._opts.networkOpts.maxTunnels, tunnelServerPort: this._opts.networkOpts.tunnelServerPort, tunnelGatewayRange: this._opts.networkOpts.tunnelGatewayRange, bridgeUri: this._opts.networkOpts.bridgeUri, logger: this._logger, seedList: this._opts.networkOpts.seedList }); // When our context is good, set up our subscriptions this._amqpContext.on('ready', this._initMessageBus.bind(this)); // When we are all connected, fire the callback this.once('ready', function() { this.removeAllListeners('error'); callback(); }); // Otherwise bubble any errors this.once('error', function(err) { this.removeAllListeners('ready'); callback(err); }); }; /** * @callback Renter~startCallback * @param {Error} [error] */ /** * Initialize the rabbitmq message bus * @private */ Renter.prototype._initMessageBus = function() { var self = this; // Setup our amqp sockets this.notifier = this._amqpContext.socket('PUBLISH'); this.publisher = this._amqpContext.socket('PUBLISH'); this.subscriber = this._amqpContext.socket('SUBSCRIBE'); this.worker = this._amqpContext.socket('WORKER'); // Connect to our renter friends and our landlord this.notifier.connect('work.close'); this.publisher.connect('pool'); this.subscriber.connect('pool'); this.worker.connect('work.open'); // Set up handlers for receiving work // Set up handlers for renter alerts this.worker.on('data', this._handleWork.bind(this)); this.subscriber.on('data', this._handleAlert.bind(this)); this.network.join(function(err) { if (err) { return self.emit('error', err); } // Set up our internal alerts for other renters self._handleNetworkEvents(); }); }; /** * Listens for network events and fires their appropriate handlers * @private */ Renter.prototype._handleNetworkEvents = function() { // Listen for unhandled offers and alert our renter friends // Listen for resolved unhandled offers and alert our renter friends this.network.on('unhandledOffer', this._onUnhandledOffer.bind(this)); this.network.on('unhandledOfferResolved', this._onResolvedOffer.bind(this)); // Good to go! this.emit('ready'); }; /** * Handles work received from a landlord * @private */ Renter.prototype._handleWork = function(buffer) { var self = this; var data = JSON.parse(buffer.toString()); // Acknowledge we have received the work this.worker.ack(); this._logger.info('received job %s', data.id); if (Renter.SAFE_LANDLORD_METHODS.indexOf(data.method) === -1) { this._logger.warn('cannot call method %s', data.method); return this.notifier.write(new Buffer(JSON.stringify({ id: data.id, error: { code: -32601, message: 'Method not found' } }))); } data.params.push(function(err) { if (err) { return self.notifier.write(new Buffer(JSON.stringify({ id: data.id, error: { code: -32603, message: err.message } }))); } var args = self._serializeArguments(data.method, arguments); self.notifier.write(new Buffer(JSON.stringify({ id: data.id, result: args }))); }); this._logger.info('calling method: %s', data.method); try { this.network[data.method].apply( this.network, this._deserializeArguments(data.method, data.params) ); } catch (err) { self.notifier.write(new Buffer(JSON.stringify({ id: data.id, error: { code: -32603, message: err.message } }))); } }; /** * Handles alerts from other renters * @private */ Renter.prototype._handleAlert = function(buffer) { var self = this; var data = JSON.parse(buffer.toString()); // If this is a response to us and we are waiting, call our callback if (this._pendingCallbacks[data.id]) { return this._pendingCallbacks[data.id].apply(null, data.result); } // If this is a request and it's not allowed, do nothing if (Renter.SAFE_POOL_METHODS.indexOf(data.method) === -1) { return; } // Add a callback function to the supplied params that only publishes // a response if the result is positive data.params.push(function(err, isAwaitingOfferOrDidEndNegotiation) { if (err || !isAwaitingOfferOrDidEndNegotiation) { return; } self.publisher.publish('pool', new Buffer(JSON.stringify({ id: data.id, result: [null, true] }))); }); // Call the method on the network interface this.network[data.method].apply(this.network, data.params); }; /** * Alert our renter friends when we get an unhandled offer * @private */ Renter.prototype._onUnhandledOffer = function(contact, contract, resolver) { var self = this; var callbackId = uuid.v4(); // Set up a callback for waiting on a response for the pool this._pendingCallbacks[callbackId] = function(err, isAwaiting) { resolver( err || (!isAwaiting ? new Error('Failed to handle offer') : null) ); }; // Ask the pool if any of our renter friends are waiting on an offer this.publisher.publish('pool', new Buffer(JSON.stringify({ id: callbackId, method: 'isAwaitingOffer', params: [ contract.get('data_hash') ] }))); setTimeout(function() { if (self._pendingCallbacks[callbackId]) { self._pendingCallbacks[callbackId]( new Error('No renters in pool are waiting for offer') ); } }, Renter.POOL_REQUEST_TIMEOUT); }; /** * Another renter resolved our unhandled offer * @private */ Renter.prototype._onResolvedOffer = function(/* contact, contract */) { var callbackId = uuid.v4(); var args = this._serializeArguments('acceptOffer', arguments); this.publisher.publish('pool', new Buffer(JSON.stringify({ id: callbackId, method: 'acceptOffer', params: args }))); }; /** * Deserializes the arguments passed back to the bus * @param {String} method - The method name to call * @param {Array} argmuments - The arguments passed to the method * @returns {Array} args */ Renter.prototype._deserializeArguments = function(method, args) { /* jshint maxcomplexity:false */ switch (method) { case 'getConsignmentPointer': args[0] = storj.Contact(args[0]); args[1] = storj.Contract.fromObject(args[1]); args[2] = storj.AuditStream.fromRecords( args[2].challenges, args[2].tree ); break; case 'getRetrievalPointer': args[0] = storj.Contact(args[0]); args[1] = storj.Contract.fromObject(args[1]); break; case 'getMirrorNodes': args[0] = args[0].map(function(pointerData) { return storj.DataChannelPointer( storj.Contact(pointerData.contact), pointerData.hash, pointerData.token, pointerData.operation ); }); args[1] = args[1].map(function(contactData) { return storj.Contact(contactData); }); break; case 'getStorageProof': args[0] = storj.Contact(args[0]); args[1] = storj.StorageItem(args[1]); break; case 'getStorageOffer': args[0] = storj.Contract.fromObject(args[0]); args[2] = typeof args[1] === 'function' ? args[1] : args[2]; args[1] = Array.isArray(args[1]) ? args[1] : []; break; case 'acceptOffer': args[1] = storj.Contract.fromObject(args[1]); break; default: // noop } return args; }; /** * Serializes the arguments passed back to the bus * @param {String} method - The method name to call * @param {Array} argmuments - The arguments passed to the method * @returns {Array} args */ Renter.prototype._serializeArguments = function(method, args) { /* jshint maxcomplexity:false */ switch (method) { case 'getConsignmentPointer': break; case 'getRetrievalPointer': break; case 'getMirrorNodes': break; case 'getStorageProof': break; case 'getStorageOffer': args[2] = args[2].toObject(); break; case 'acceptOffer': args[2] = args[2].toObject(); break; default: // noop } return args; }; module.exports = Renter; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Global Members createClient Client Source: index.js createConfig module:complex/config Source: index.js createLandlord Landlord Source: index.js createRenter Renter Source: index.js Methods module:complex/config(configFilePath) Loads the appropriate config type Parameters: Name Type Description configFilePath String The path to the config file on disk Source: lib/config.js × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Modules Classes Client Landlord BaseConfig LandlordConfig RenterConfig Renter × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Classes Classes Client Landlord BaseConfig LandlordConfig RenterConfig Renter × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Manage many renter nodes with the same identity with remote control capabilities! Complete documentation can be found here. Prerequisites Storj Core MongoDB RabbitMQ InstallationCommand Line Interfacenpm install -g storj-complexProgrammaticnpm install storj-complex --saveUsageCommand Line Interfacestorj-complex &lt;path/to/config.json&gt;ProgrammaticSet up a renter service and landlord to control it. var complex = require('storj-complex'); var landlord = complex.createLandlord({ /* landlord config */ }); var renter = complex.createRenter({ /* renter config */ }); // Landlords boss around renters... // Rather they control all renters connected to the same RabbitMQ landlord.start(function(err) { // Landlord is connected and service listening for RPC commands }); // Renters do what landlords tell them... // Rather they listen for tasks and coordinate to appease their masters renter.start(function(err) { // Renter is connected to the storj network and listening for work }); // Landlords and Renters are ReadableStreams // The pump out newline-terminated JSON strings for logging information landlord.pipe(process.stdout); renter.pipe(process.stdout);Create a client to issue RPC commands to the landlord: var complex = require('storj-complex'); var client = complex.createClient({ /* options */ }); var contract = new storj.Contract({ /* contract data */ }); // The client mimics storj-lib's RenterInterface client.getStorageOffer(contract, function(err, farmer, contract) { // Storage offer received and accepted for the supplied farmer });LicenseStorj Complex - Manage many renter nodes with remote control capabilitiesCopyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see http://www.gnu.org/licenses/. × Search results Close "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Class: Client Client new Client(options) Creates a RPC client for communicating with a Landlord Parameters: Name Type Description options Object Properties Name Type Description rpcUrl String The URL of the Landlord RPC server rpcUser String Authorization username rpcPassword String Authorization password Source: lib/client.js Methods _deserializeResponseArguments(method, arguments) Converts response params into storj-lib objects Parameters: Name Type Description method String arguments Array Source: lib/client.js Returns: Type Array _serializeRequestArguments(method, arguments) Converts storj-lib objects into request params Parameters: Name Type Description method String arguments Array Source: lib/client.js Returns: Type Array getConsignmentPointer() Source: lib/client.js See: http://storj.github.io/core/RenterInterface.html getMirrorNodes() Source: lib/client.js See: http://storj.github.io/core/RenterInterface.html getRetrievalPointer() Source: lib/client.js See: http://storj.github.io/core/RenterInterface.html getStorageOffer() Source: lib/client.js See: http://storj.github.io/core/RenterInterface.html getStorageProof() Source: lib/client.js See: http://storj.github.io/core/RenterInterface.html × Search results Close "},"Landlord.html":{"id":"Landlord.html","title":"Class: Landlord","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Class: Landlord Landlord new Landlord(options) Creates an RPC server for issuing work to a renter pool Parameters: Name Type Description options Object Properties Name Type Description serverPort Number The port to listen on serverOpts Object Options to pass wot Restify server amqpUrl String The RabbitMQ server URL amqpOpts Object Option to pass to RabbitMQ context logLevel Number The verbosity level for logging Source: lib/landlord.js Methods start(callback) Starts the landlord service Parameters: Name Type Description callback Landlord~startCallback Source: lib/landlord.js Type Definitions startCallback( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; Source: lib/landlord.js × Search results Close "},"module-complex_config.html":{"id":"module-complex_config.html","title":"Module: complex/config","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Module: complex/config (require(&quot;complex/config&quot;))(configFilePath) Loads the appropriate config type Parameters: Name Type Description configFilePath String The path to the config file on disk Source: lib/config.js Classes BaseConfig LandlordConfig RenterConfig × Search results Close "},"module-complex_config-BaseConfig.html":{"id":"module-complex_config-BaseConfig.html","title":"Class: BaseConfig","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Class: BaseConfig complex/config~ BaseConfig new BaseConfig(config) Abstract config for renters and landlords Parameters: Name Type Description config Object Properties Name Type Description amqpUrl String The URL for RabbitMQ amqpOpts Object Options to pass to Rabbit.js logLevel Number Verbosity level for logging Source: lib/config.js Methods toObject() Returns an plain object Source: lib/config.js × Search results Close "},"module-complex_config-LandlordConfig.html":{"id":"module-complex_config-LandlordConfig.html","title":"Class: LandlordConfig","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Class: LandlordConfig complex/config~ LandlordConfig new LandlordConfig(options) Config for landlords Parameters: Name Type Description options Object Properties Name Type Description serverPort Number The port to listen on serverOpts Object Properties Name Type Description certificate String PEM SSL certificate key String PEM SSL key Source: lib/config.js Extends BaseConfig × Search results Close "},"module-complex_config-RenterConfig.html":{"id":"module-complex_config-RenterConfig.html","title":"Class: RenterConfig","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Class: RenterConfig complex/config~ RenterConfig new RenterConfig(options) Config for renters Parameters: Name Type Description options Object Properties Name Type Description mongoUrl String The URL for the MongoDB mongoOpts Object Options to pass to Mongoose networkPrivateKey String The private key for the renter networkOpts Object Options to pass to RenterInterface Source: lib/config.js Extends BaseConfig × Search results Close "},"Renter.html":{"id":"Renter.html","title":"Class: Renter","body":" Storj Complex Modules complex/config Classes ClientLandlordcomplex/config~BaseConfigcomplex/config~LandlordConfigcomplex/config~RenterConfigRenter Global createClientcreateConfigcreateLandlordcreateRenter Class: Renter Renter new Renter(options) Create a renter interface capable of coordinating with other renters Parameters: Name Type Description options Object Properties Name Type Description mongoUrl String The URL for the MongoDB mongoOpts Object Options to pass to Mongoose networkPrivateKey String The private key for the renter networkOpts Object Options to pass to RenterInterface amqpUrl String The URL for the RabbitMQ server amqpOpts Object Options to pass the RabbitMQ context logLevel Number The verbosity level for logging Source: lib/renter.js Methods _deserializeArguments(method, argmuments) Deserializes the arguments passed back to the bus Parameters: Name Type Description method String The method name to call argmuments Array The arguments passed to the method Source: lib/renter.js Returns: args Type Array _serializeArguments(method, argmuments) Serializes the arguments passed back to the bus Parameters: Name Type Description method String The method name to call argmuments Array The arguments passed to the method Source: lib/renter.js Returns: args Type Array start(callback) Starts the renter service Parameters: Name Type Description callback Renter~startCallback Source: lib/renter.js Type Definitions startCallback( [error]) Parameters: Name Type Argument Description error Error &lt;optional&gt; Source: lib/renter.js × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
